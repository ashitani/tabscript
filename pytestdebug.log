============================= test session starts ==============================
platform darwin -- Python 3.7.7, pytest-5.4.2, py-1.8.1, pluggy-0.13.1 -- /Users/ashiya/.pyenv/versions/3.7.7/bin/python3.7
cachedir: .pytest_cache
rootdir: /Users/ashiya/git/tabscript, inifile: pytest.ini
collecting ... collected 18 items

tests/parser/test_03_bar_content.py::test_basic_note_parsing FAILED      [  5%]
tests/parser/test_03_bar_content.py::test_chord_parsing FAILED           [ 11%]
tests/parser/test_03_bar_content.py::test_rest_parsing FAILED            [ 16%]
tests/parser/test_03_bar_content.py::test_duration_inheritance FAILED    [ 22%]
tests/parser/test_03_bar_content.py::test_dotted_duration FAILED         [ 27%]
tests/parser/test_03_bar_content.py::test_invalid_note_format FAILED     [ 33%]
tests/parser/test_03_bar_content.py::test_muted_note FAILED              [ 38%]
tests/parser/test_03_bar_content.py::test_chord_notation FAILED          [ 44%]
tests/parser/test_03_bar_content.py::test_inheritance FAILED             [ 50%]
tests/parser/test_03_bar_content.py::test_move_notation FAILED           [ 55%]
tests/parser/test_03_bar_content.py::test_tie_slur_notation FAILED       [ 61%]
tests/parser/test_03_bar_content.py::test_repeat_bar_parsing PASSED      [ 66%]
tests/parser/test_03_bar_content.py::test_volta_bracket_parsing PASSED   [ 72%]
tests/parser/test_03_bar_content.py::test_multi_bar_volta_bracket_parsing PASSED [ 77%]
tests/parser/test_03_bar_content.py::test_string_movement_notation FAILED [ 83%]
tests/parser/test_03_bar_content.py::test_string_movement_duration_calculation FAILED [ 88%]
tests/parser/test_03_bar_content.py::test_chord_duration_calculation FAILED [ 94%]
tests/parser/test_03_bar_content.py::test_continued_string_movement FAILED [100%]

=================================== FAILURES ===================================
___________________________ test_basic_note_parsing ____________________________

debug_level = 0

    def test_basic_note_parsing(debug_level):
        """基本的な音符のパースをテスト"""
        parser = Parser(debug_mode=True, debug_level=debug_level, skip_validation=True)
        parser.score = Score(title="", tuning="guitar", beat="4/4")
    
        # 基本的な音符表記
>       bar = parser._parse_bar_line("1-0:4 2-2:8 3-3:16 4-4:32")

tests/parser/test_03_bar_content.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/tabscript/parser.py:575: in _parse_bar_line
    note = self._parse_note(token, self.last_duration, chord)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tabscript.parser.Parser object at 0x109773c10>, token = '1-0:4'
default_duration = '4', chord = None

    def _parse_note(self, token: str, default_duration: str = "4", chord: Optional[str] = None) -> Note:
        """音符トークンをパース"""
        self.debug_print(f"Processing token: {token}", level=3)
    
        # コード形式の音符（括弧で囲まれた複数の音符）
        if token.startswith('(') and ')' in token:
            self.debug_print("Processing as chord notation", level=3)
    
            # 括弧内の音符と音価を分離
            chord_part, *rest = token.split(')')
            chord_notes_str = chord_part[1:]  # 先頭の'('を除去
    
            # 音価の取得
            duration = default_duration
            if rest and ':' in rest[0]:
                duration = rest[0].split(':')[1]
                self.debug_print(f"Chord duration: {duration}", level=3)
    
            # 括弧内の音符をパース
            chord_notes = []
            for note_str in chord_notes_str.split():
                # コード内の音符は音価を持たない（コード全体の音価を使用）
                if ':' in note_str:
                    note_str = note_str.split(':')[0]
    
                # 個々の音符をパース
                note = self._parse_note(note_str, duration, chord)
                note.duration = duration  # コード全体の音価を設定
                note.is_chord = True  # コードの一部であることを明示
                chord_notes.append(note)
    
            # コードの先頭音符を返す（他の音符はchord_notesに格納）
            if chord_notes:
                main_note = chord_notes[0]
                main_note.is_chord_start = True  # コードの先頭音符であることを明示
                main_note.chord_notes = chord_notes[1:]  # 先頭以外の音符
                self.debug_print(f"Created chord with {len(chord_notes)} notes, duration={main_note.duration}", level=3)
                return main_note
            else:
                raise ParseError(f"Empty chord notation: {token}", self.current_line)
    
        # 休符の処理
        if token.startswith('r'):
            self.debug_print("Processing as rest", level=3)
            duration = token[1:] if len(token) > 1 else default_duration
            self._validate_duration(duration)
            return Note(
                string=0,
                fret="0",
                duration=duration,
                chord=chord,
                is_rest=True
            )
    
        # 弦移動の処理
        if token.startswith('u') or token.startswith('d'):
            direction = token[0]
            try:
                fret = token[1:].split(':')[0]  # 移動後のフレット番号
    
                # 弦番号の計算
                if direction == 'u':
                    string = self.last_string - 1  # 1弦上に移動
                else:  # direction == 'd'
                    string = self.last_string + 1  # 1弦下に移動
    
                # 弦番号の範囲チェック
                if string < 1:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # チューニングに基づいて弦の数を決定
                if self.score.tuning == "guitar":
                    max_strings = 6
                elif self.score.tuning == "bass":
                    max_strings = 4
                elif self.score.tuning == "ukulele":
                    max_strings = 4
                elif self.score.tuning == "guitar7":
                    max_strings = 7
                elif self.score.tuning == "bass5":
                    max_strings = 5
                else:
                    max_strings = 6  # デフォルト
    
                # 弦番号の範囲チェック（下限）
                if string > max_strings:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # 弦番号を更新
                self.last_string = string
    
                # 音価の取得
                if ':' in token:
                    duration = token.split(':')[1]
                else:
                    duration = default_duration
    
                # 新しい音符を作成して返す
                return Note(
                    string=string,
                    fret=fret,
                    duration=duration,
                    chord=chord,
                    is_up_move=(direction == 'u'),
                    is_down_move=(direction == 'd')
                )
            except ValueError:
                raise ParseError(f"Invalid string movement: {token}", self.current_line)
    
        # 弦-フレット形式の解析
        if '-' in token:
            string_fret = token.split('-')
            string = int(string_fret[0])
            fret = string_fret[1].upper()  # フレット番号を大文字に統一
    
            # 0-0は休符として扱う
            is_rest = (string == 0 and fret == "0")
    
            # ミュート音の処理
            is_muted = (fret == "X")
    
            # フレット番号の検証（ミュート音以外）
            if not is_muted and not is_rest:
>               self._validate_fret(fret)
E               AttributeError: 'Parser' object has no attribute '_validate_fret'

src/tabscript/parser.py:716: AttributeError
______________________________ test_chord_parsing ______________________________

    def test_chord_parsing():
        """コード名のパースをテスト"""
        parser = Parser()
        parser.score = Score(title="", tuning="guitar", beat="4/4")  # スコアを初期化
    
        # 基本的なコード
>       bar = parser._parse_bar_line("@Cmaj7 3-3:4 4-4:4")

tests/parser/test_03_bar_content.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/tabscript/parser.py:575: in _parse_bar_line
    note = self._parse_note(token, self.last_duration, chord)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tabscript.parser.Parser object at 0x109945890>, token = '3-3:4'
default_duration = '4', chord = 'Cmaj7'

    def _parse_note(self, token: str, default_duration: str = "4", chord: Optional[str] = None) -> Note:
        """音符トークンをパース"""
        self.debug_print(f"Processing token: {token}", level=3)
    
        # コード形式の音符（括弧で囲まれた複数の音符）
        if token.startswith('(') and ')' in token:
            self.debug_print("Processing as chord notation", level=3)
    
            # 括弧内の音符と音価を分離
            chord_part, *rest = token.split(')')
            chord_notes_str = chord_part[1:]  # 先頭の'('を除去
    
            # 音価の取得
            duration = default_duration
            if rest and ':' in rest[0]:
                duration = rest[0].split(':')[1]
                self.debug_print(f"Chord duration: {duration}", level=3)
    
            # 括弧内の音符をパース
            chord_notes = []
            for note_str in chord_notes_str.split():
                # コード内の音符は音価を持たない（コード全体の音価を使用）
                if ':' in note_str:
                    note_str = note_str.split(':')[0]
    
                # 個々の音符をパース
                note = self._parse_note(note_str, duration, chord)
                note.duration = duration  # コード全体の音価を設定
                note.is_chord = True  # コードの一部であることを明示
                chord_notes.append(note)
    
            # コードの先頭音符を返す（他の音符はchord_notesに格納）
            if chord_notes:
                main_note = chord_notes[0]
                main_note.is_chord_start = True  # コードの先頭音符であることを明示
                main_note.chord_notes = chord_notes[1:]  # 先頭以外の音符
                self.debug_print(f"Created chord with {len(chord_notes)} notes, duration={main_note.duration}", level=3)
                return main_note
            else:
                raise ParseError(f"Empty chord notation: {token}", self.current_line)
    
        # 休符の処理
        if token.startswith('r'):
            self.debug_print("Processing as rest", level=3)
            duration = token[1:] if len(token) > 1 else default_duration
            self._validate_duration(duration)
            return Note(
                string=0,
                fret="0",
                duration=duration,
                chord=chord,
                is_rest=True
            )
    
        # 弦移動の処理
        if token.startswith('u') or token.startswith('d'):
            direction = token[0]
            try:
                fret = token[1:].split(':')[0]  # 移動後のフレット番号
    
                # 弦番号の計算
                if direction == 'u':
                    string = self.last_string - 1  # 1弦上に移動
                else:  # direction == 'd'
                    string = self.last_string + 1  # 1弦下に移動
    
                # 弦番号の範囲チェック
                if string < 1:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # チューニングに基づいて弦の数を決定
                if self.score.tuning == "guitar":
                    max_strings = 6
                elif self.score.tuning == "bass":
                    max_strings = 4
                elif self.score.tuning == "ukulele":
                    max_strings = 4
                elif self.score.tuning == "guitar7":
                    max_strings = 7
                elif self.score.tuning == "bass5":
                    max_strings = 5
                else:
                    max_strings = 6  # デフォルト
    
                # 弦番号の範囲チェック（下限）
                if string > max_strings:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # 弦番号を更新
                self.last_string = string
    
                # 音価の取得
                if ':' in token:
                    duration = token.split(':')[1]
                else:
                    duration = default_duration
    
                # 新しい音符を作成して返す
                return Note(
                    string=string,
                    fret=fret,
                    duration=duration,
                    chord=chord,
                    is_up_move=(direction == 'u'),
                    is_down_move=(direction == 'd')
                )
            except ValueError:
                raise ParseError(f"Invalid string movement: {token}", self.current_line)
    
        # 弦-フレット形式の解析
        if '-' in token:
            string_fret = token.split('-')
            string = int(string_fret[0])
            fret = string_fret[1].upper()  # フレット番号を大文字に統一
    
            # 0-0は休符として扱う
            is_rest = (string == 0 and fret == "0")
    
            # ミュート音の処理
            is_muted = (fret == "X")
    
            # フレット番号の検証（ミュート音以外）
            if not is_muted and not is_rest:
>               self._validate_fret(fret)
E               AttributeError: 'Parser' object has no attribute '_validate_fret'

src/tabscript/parser.py:716: AttributeError
______________________________ test_rest_parsing _______________________________

    def test_rest_parsing():
        """休符のパースをテスト"""
        parser = Parser()
        parser.score = Score(title="", tuning="guitar", beat="4/4")  # スコアを初期化
    
        # 休符を含む小節
>       bar = parser._parse_bar_line("3-3:4 0-0:4 5-5:4")  # 0-0は休符として扱われる

tests/parser/test_03_bar_content.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/tabscript/parser.py:575: in _parse_bar_line
    note = self._parse_note(token, self.last_duration, chord)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tabscript.parser.Parser object at 0x1097d85d0>, token = '3-3:4'
default_duration = '4', chord = None

    def _parse_note(self, token: str, default_duration: str = "4", chord: Optional[str] = None) -> Note:
        """音符トークンをパース"""
        self.debug_print(f"Processing token: {token}", level=3)
    
        # コード形式の音符（括弧で囲まれた複数の音符）
        if token.startswith('(') and ')' in token:
            self.debug_print("Processing as chord notation", level=3)
    
            # 括弧内の音符と音価を分離
            chord_part, *rest = token.split(')')
            chord_notes_str = chord_part[1:]  # 先頭の'('を除去
    
            # 音価の取得
            duration = default_duration
            if rest and ':' in rest[0]:
                duration = rest[0].split(':')[1]
                self.debug_print(f"Chord duration: {duration}", level=3)
    
            # 括弧内の音符をパース
            chord_notes = []
            for note_str in chord_notes_str.split():
                # コード内の音符は音価を持たない（コード全体の音価を使用）
                if ':' in note_str:
                    note_str = note_str.split(':')[0]
    
                # 個々の音符をパース
                note = self._parse_note(note_str, duration, chord)
                note.duration = duration  # コード全体の音価を設定
                note.is_chord = True  # コードの一部であることを明示
                chord_notes.append(note)
    
            # コードの先頭音符を返す（他の音符はchord_notesに格納）
            if chord_notes:
                main_note = chord_notes[0]
                main_note.is_chord_start = True  # コードの先頭音符であることを明示
                main_note.chord_notes = chord_notes[1:]  # 先頭以外の音符
                self.debug_print(f"Created chord with {len(chord_notes)} notes, duration={main_note.duration}", level=3)
                return main_note
            else:
                raise ParseError(f"Empty chord notation: {token}", self.current_line)
    
        # 休符の処理
        if token.startswith('r'):
            self.debug_print("Processing as rest", level=3)
            duration = token[1:] if len(token) > 1 else default_duration
            self._validate_duration(duration)
            return Note(
                string=0,
                fret="0",
                duration=duration,
                chord=chord,
                is_rest=True
            )
    
        # 弦移動の処理
        if token.startswith('u') or token.startswith('d'):
            direction = token[0]
            try:
                fret = token[1:].split(':')[0]  # 移動後のフレット番号
    
                # 弦番号の計算
                if direction == 'u':
                    string = self.last_string - 1  # 1弦上に移動
                else:  # direction == 'd'
                    string = self.last_string + 1  # 1弦下に移動
    
                # 弦番号の範囲チェック
                if string < 1:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # チューニングに基づいて弦の数を決定
                if self.score.tuning == "guitar":
                    max_strings = 6
                elif self.score.tuning == "bass":
                    max_strings = 4
                elif self.score.tuning == "ukulele":
                    max_strings = 4
                elif self.score.tuning == "guitar7":
                    max_strings = 7
                elif self.score.tuning == "bass5":
                    max_strings = 5
                else:
                    max_strings = 6  # デフォルト
    
                # 弦番号の範囲チェック（下限）
                if string > max_strings:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # 弦番号を更新
                self.last_string = string
    
                # 音価の取得
                if ':' in token:
                    duration = token.split(':')[1]
                else:
                    duration = default_duration
    
                # 新しい音符を作成して返す
                return Note(
                    string=string,
                    fret=fret,
                    duration=duration,
                    chord=chord,
                    is_up_move=(direction == 'u'),
                    is_down_move=(direction == 'd')
                )
            except ValueError:
                raise ParseError(f"Invalid string movement: {token}", self.current_line)
    
        # 弦-フレット形式の解析
        if '-' in token:
            string_fret = token.split('-')
            string = int(string_fret[0])
            fret = string_fret[1].upper()  # フレット番号を大文字に統一
    
            # 0-0は休符として扱う
            is_rest = (string == 0 and fret == "0")
    
            # ミュート音の処理
            is_muted = (fret == "X")
    
            # フレット番号の検証（ミュート音以外）
            if not is_muted and not is_rest:
>               self._validate_fret(fret)
E               AttributeError: 'Parser' object has no attribute '_validate_fret'

src/tabscript/parser.py:716: AttributeError
__________________________ test_duration_inheritance ___________________________

    def test_duration_inheritance():
        """音価の継承をテスト"""
        parser = Parser()
        parser.score = Score(title="", tuning="guitar", beat="4/4")  # スコアを初期化
>       bar = parser._parse_bar_line("3-3:8 4-4 5-5 6-6")

tests/parser/test_03_bar_content.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/tabscript/parser.py:575: in _parse_bar_line
    note = self._parse_note(token, self.last_duration, chord)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tabscript.parser.Parser object at 0x109873910>, token = '3-3:8'
default_duration = '4', chord = None

    def _parse_note(self, token: str, default_duration: str = "4", chord: Optional[str] = None) -> Note:
        """音符トークンをパース"""
        self.debug_print(f"Processing token: {token}", level=3)
    
        # コード形式の音符（括弧で囲まれた複数の音符）
        if token.startswith('(') and ')' in token:
            self.debug_print("Processing as chord notation", level=3)
    
            # 括弧内の音符と音価を分離
            chord_part, *rest = token.split(')')
            chord_notes_str = chord_part[1:]  # 先頭の'('を除去
    
            # 音価の取得
            duration = default_duration
            if rest and ':' in rest[0]:
                duration = rest[0].split(':')[1]
                self.debug_print(f"Chord duration: {duration}", level=3)
    
            # 括弧内の音符をパース
            chord_notes = []
            for note_str in chord_notes_str.split():
                # コード内の音符は音価を持たない（コード全体の音価を使用）
                if ':' in note_str:
                    note_str = note_str.split(':')[0]
    
                # 個々の音符をパース
                note = self._parse_note(note_str, duration, chord)
                note.duration = duration  # コード全体の音価を設定
                note.is_chord = True  # コードの一部であることを明示
                chord_notes.append(note)
    
            # コードの先頭音符を返す（他の音符はchord_notesに格納）
            if chord_notes:
                main_note = chord_notes[0]
                main_note.is_chord_start = True  # コードの先頭音符であることを明示
                main_note.chord_notes = chord_notes[1:]  # 先頭以外の音符
                self.debug_print(f"Created chord with {len(chord_notes)} notes, duration={main_note.duration}", level=3)
                return main_note
            else:
                raise ParseError(f"Empty chord notation: {token}", self.current_line)
    
        # 休符の処理
        if token.startswith('r'):
            self.debug_print("Processing as rest", level=3)
            duration = token[1:] if len(token) > 1 else default_duration
            self._validate_duration(duration)
            return Note(
                string=0,
                fret="0",
                duration=duration,
                chord=chord,
                is_rest=True
            )
    
        # 弦移動の処理
        if token.startswith('u') or token.startswith('d'):
            direction = token[0]
            try:
                fret = token[1:].split(':')[0]  # 移動後のフレット番号
    
                # 弦番号の計算
                if direction == 'u':
                    string = self.last_string - 1  # 1弦上に移動
                else:  # direction == 'd'
                    string = self.last_string + 1  # 1弦下に移動
    
                # 弦番号の範囲チェック
                if string < 1:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # チューニングに基づいて弦の数を決定
                if self.score.tuning == "guitar":
                    max_strings = 6
                elif self.score.tuning == "bass":
                    max_strings = 4
                elif self.score.tuning == "ukulele":
                    max_strings = 4
                elif self.score.tuning == "guitar7":
                    max_strings = 7
                elif self.score.tuning == "bass5":
                    max_strings = 5
                else:
                    max_strings = 6  # デフォルト
    
                # 弦番号の範囲チェック（下限）
                if string > max_strings:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # 弦番号を更新
                self.last_string = string
    
                # 音価の取得
                if ':' in token:
                    duration = token.split(':')[1]
                else:
                    duration = default_duration
    
                # 新しい音符を作成して返す
                return Note(
                    string=string,
                    fret=fret,
                    duration=duration,
                    chord=chord,
                    is_up_move=(direction == 'u'),
                    is_down_move=(direction == 'd')
                )
            except ValueError:
                raise ParseError(f"Invalid string movement: {token}", self.current_line)
    
        # 弦-フレット形式の解析
        if '-' in token:
            string_fret = token.split('-')
            string = int(string_fret[0])
            fret = string_fret[1].upper()  # フレット番号を大文字に統一
    
            # 0-0は休符として扱う
            is_rest = (string == 0 and fret == "0")
    
            # ミュート音の処理
            is_muted = (fret == "X")
    
            # フレット番号の検証（ミュート音以外）
            if not is_muted and not is_rest:
>               self._validate_fret(fret)
E               AttributeError: 'Parser' object has no attribute '_validate_fret'

src/tabscript/parser.py:716: AttributeError
_____________________________ test_dotted_duration _____________________________

    def test_dotted_duration():
        """付点音符のパースをテスト"""
        parser = Parser()
        parser.score = Score(title="", tuning="guitar", beat="4/4")  # スコアを初期化
>       bar = parser._parse_bar_line("3-3:4. 4-4:8.")

tests/parser/test_03_bar_content.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/tabscript/parser.py:575: in _parse_bar_line
    note = self._parse_note(token, self.last_duration, chord)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tabscript.parser.Parser object at 0x1097733d0>, token = '3-3:4.'
default_duration = '4', chord = None

    def _parse_note(self, token: str, default_duration: str = "4", chord: Optional[str] = None) -> Note:
        """音符トークンをパース"""
        self.debug_print(f"Processing token: {token}", level=3)
    
        # コード形式の音符（括弧で囲まれた複数の音符）
        if token.startswith('(') and ')' in token:
            self.debug_print("Processing as chord notation", level=3)
    
            # 括弧内の音符と音価を分離
            chord_part, *rest = token.split(')')
            chord_notes_str = chord_part[1:]  # 先頭の'('を除去
    
            # 音価の取得
            duration = default_duration
            if rest and ':' in rest[0]:
                duration = rest[0].split(':')[1]
                self.debug_print(f"Chord duration: {duration}", level=3)
    
            # 括弧内の音符をパース
            chord_notes = []
            for note_str in chord_notes_str.split():
                # コード内の音符は音価を持たない（コード全体の音価を使用）
                if ':' in note_str:
                    note_str = note_str.split(':')[0]
    
                # 個々の音符をパース
                note = self._parse_note(note_str, duration, chord)
                note.duration = duration  # コード全体の音価を設定
                note.is_chord = True  # コードの一部であることを明示
                chord_notes.append(note)
    
            # コードの先頭音符を返す（他の音符はchord_notesに格納）
            if chord_notes:
                main_note = chord_notes[0]
                main_note.is_chord_start = True  # コードの先頭音符であることを明示
                main_note.chord_notes = chord_notes[1:]  # 先頭以外の音符
                self.debug_print(f"Created chord with {len(chord_notes)} notes, duration={main_note.duration}", level=3)
                return main_note
            else:
                raise ParseError(f"Empty chord notation: {token}", self.current_line)
    
        # 休符の処理
        if token.startswith('r'):
            self.debug_print("Processing as rest", level=3)
            duration = token[1:] if len(token) > 1 else default_duration
            self._validate_duration(duration)
            return Note(
                string=0,
                fret="0",
                duration=duration,
                chord=chord,
                is_rest=True
            )
    
        # 弦移動の処理
        if token.startswith('u') or token.startswith('d'):
            direction = token[0]
            try:
                fret = token[1:].split(':')[0]  # 移動後のフレット番号
    
                # 弦番号の計算
                if direction == 'u':
                    string = self.last_string - 1  # 1弦上に移動
                else:  # direction == 'd'
                    string = self.last_string + 1  # 1弦下に移動
    
                # 弦番号の範囲チェック
                if string < 1:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # チューニングに基づいて弦の数を決定
                if self.score.tuning == "guitar":
                    max_strings = 6
                elif self.score.tuning == "bass":
                    max_strings = 4
                elif self.score.tuning == "ukulele":
                    max_strings = 4
                elif self.score.tuning == "guitar7":
                    max_strings = 7
                elif self.score.tuning == "bass5":
                    max_strings = 5
                else:
                    max_strings = 6  # デフォルト
    
                # 弦番号の範囲チェック（下限）
                if string > max_strings:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # 弦番号を更新
                self.last_string = string
    
                # 音価の取得
                if ':' in token:
                    duration = token.split(':')[1]
                else:
                    duration = default_duration
    
                # 新しい音符を作成して返す
                return Note(
                    string=string,
                    fret=fret,
                    duration=duration,
                    chord=chord,
                    is_up_move=(direction == 'u'),
                    is_down_move=(direction == 'd')
                )
            except ValueError:
                raise ParseError(f"Invalid string movement: {token}", self.current_line)
    
        # 弦-フレット形式の解析
        if '-' in token:
            string_fret = token.split('-')
            string = int(string_fret[0])
            fret = string_fret[1].upper()  # フレット番号を大文字に統一
    
            # 0-0は休符として扱う
            is_rest = (string == 0 and fret == "0")
    
            # ミュート音の処理
            is_muted = (fret == "X")
    
            # フレット番号の検証（ミュート音以外）
            if not is_muted and not is_rest:
>               self._validate_fret(fret)
E               AttributeError: 'Parser' object has no attribute '_validate_fret'

src/tabscript/parser.py:716: AttributeError
___________________________ test_invalid_note_format ___________________________

    def test_invalid_note_format():
        """不正な音符形式をテスト"""
        parser = Parser()
        parser.score = Score(title="", tuning="guitar", beat="4/4")  # スコアを初期化
    
        with pytest.raises(ParseError, match="Invalid fret number"):
>           parser._parse_bar_line("3-A:4")  # 不正なフレット番号（アルファベット）

tests/parser/test_03_bar_content.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/tabscript/parser.py:575: in _parse_bar_line
    note = self._parse_note(token, self.last_duration, chord)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tabscript.parser.Parser object at 0x109945b10>, token = '3-A:4'
default_duration = '4', chord = None

    def _parse_note(self, token: str, default_duration: str = "4", chord: Optional[str] = None) -> Note:
        """音符トークンをパース"""
        self.debug_print(f"Processing token: {token}", level=3)
    
        # コード形式の音符（括弧で囲まれた複数の音符）
        if token.startswith('(') and ')' in token:
            self.debug_print("Processing as chord notation", level=3)
    
            # 括弧内の音符と音価を分離
            chord_part, *rest = token.split(')')
            chord_notes_str = chord_part[1:]  # 先頭の'('を除去
    
            # 音価の取得
            duration = default_duration
            if rest and ':' in rest[0]:
                duration = rest[0].split(':')[1]
                self.debug_print(f"Chord duration: {duration}", level=3)
    
            # 括弧内の音符をパース
            chord_notes = []
            for note_str in chord_notes_str.split():
                # コード内の音符は音価を持たない（コード全体の音価を使用）
                if ':' in note_str:
                    note_str = note_str.split(':')[0]
    
                # 個々の音符をパース
                note = self._parse_note(note_str, duration, chord)
                note.duration = duration  # コード全体の音価を設定
                note.is_chord = True  # コードの一部であることを明示
                chord_notes.append(note)
    
            # コードの先頭音符を返す（他の音符はchord_notesに格納）
            if chord_notes:
                main_note = chord_notes[0]
                main_note.is_chord_start = True  # コードの先頭音符であることを明示
                main_note.chord_notes = chord_notes[1:]  # 先頭以外の音符
                self.debug_print(f"Created chord with {len(chord_notes)} notes, duration={main_note.duration}", level=3)
                return main_note
            else:
                raise ParseError(f"Empty chord notation: {token}", self.current_line)
    
        # 休符の処理
        if token.startswith('r'):
            self.debug_print("Processing as rest", level=3)
            duration = token[1:] if len(token) > 1 else default_duration
            self._validate_duration(duration)
            return Note(
                string=0,
                fret="0",
                duration=duration,
                chord=chord,
                is_rest=True
            )
    
        # 弦移動の処理
        if token.startswith('u') or token.startswith('d'):
            direction = token[0]
            try:
                fret = token[1:].split(':')[0]  # 移動後のフレット番号
    
                # 弦番号の計算
                if direction == 'u':
                    string = self.last_string - 1  # 1弦上に移動
                else:  # direction == 'd'
                    string = self.last_string + 1  # 1弦下に移動
    
                # 弦番号の範囲チェック
                if string < 1:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # チューニングに基づいて弦の数を決定
                if self.score.tuning == "guitar":
                    max_strings = 6
                elif self.score.tuning == "bass":
                    max_strings = 4
                elif self.score.tuning == "ukulele":
                    max_strings = 4
                elif self.score.tuning == "guitar7":
                    max_strings = 7
                elif self.score.tuning == "bass5":
                    max_strings = 5
                else:
                    max_strings = 6  # デフォルト
    
                # 弦番号の範囲チェック（下限）
                if string > max_strings:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # 弦番号を更新
                self.last_string = string
    
                # 音価の取得
                if ':' in token:
                    duration = token.split(':')[1]
                else:
                    duration = default_duration
    
                # 新しい音符を作成して返す
                return Note(
                    string=string,
                    fret=fret,
                    duration=duration,
                    chord=chord,
                    is_up_move=(direction == 'u'),
                    is_down_move=(direction == 'd')
                )
            except ValueError:
                raise ParseError(f"Invalid string movement: {token}", self.current_line)
    
        # 弦-フレット形式の解析
        if '-' in token:
            string_fret = token.split('-')
            string = int(string_fret[0])
            fret = string_fret[1].upper()  # フレット番号を大文字に統一
    
            # 0-0は休符として扱う
            is_rest = (string == 0 and fret == "0")
    
            # ミュート音の処理
            is_muted = (fret == "X")
    
            # フレット番号の検証（ミュート音以外）
            if not is_muted and not is_rest:
>               self._validate_fret(fret)
E               AttributeError: 'Parser' object has no attribute '_validate_fret'

src/tabscript/parser.py:716: AttributeError
_______________________________ test_muted_note ________________________________

    def test_muted_note():
        """ミュート音のパースをテスト"""
        parser = Parser()
        parser.score = Score(title="", tuning="guitar", beat="4/4")  # スコアを初期化
>       bar = parser._parse_bar_line("3-X:4 4-x:4")

tests/parser/test_03_bar_content.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/tabscript/parser.py:575: in _parse_bar_line
    note = self._parse_note(token, self.last_duration, chord)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tabscript.parser.Parser object at 0x1097822d0>, token = '3-X:4'
default_duration = '4', chord = None

    def _parse_note(self, token: str, default_duration: str = "4", chord: Optional[str] = None) -> Note:
        """音符トークンをパース"""
        self.debug_print(f"Processing token: {token}", level=3)
    
        # コード形式の音符（括弧で囲まれた複数の音符）
        if token.startswith('(') and ')' in token:
            self.debug_print("Processing as chord notation", level=3)
    
            # 括弧内の音符と音価を分離
            chord_part, *rest = token.split(')')
            chord_notes_str = chord_part[1:]  # 先頭の'('を除去
    
            # 音価の取得
            duration = default_duration
            if rest and ':' in rest[0]:
                duration = rest[0].split(':')[1]
                self.debug_print(f"Chord duration: {duration}", level=3)
    
            # 括弧内の音符をパース
            chord_notes = []
            for note_str in chord_notes_str.split():
                # コード内の音符は音価を持たない（コード全体の音価を使用）
                if ':' in note_str:
                    note_str = note_str.split(':')[0]
    
                # 個々の音符をパース
                note = self._parse_note(note_str, duration, chord)
                note.duration = duration  # コード全体の音価を設定
                note.is_chord = True  # コードの一部であることを明示
                chord_notes.append(note)
    
            # コードの先頭音符を返す（他の音符はchord_notesに格納）
            if chord_notes:
                main_note = chord_notes[0]
                main_note.is_chord_start = True  # コードの先頭音符であることを明示
                main_note.chord_notes = chord_notes[1:]  # 先頭以外の音符
                self.debug_print(f"Created chord with {len(chord_notes)} notes, duration={main_note.duration}", level=3)
                return main_note
            else:
                raise ParseError(f"Empty chord notation: {token}", self.current_line)
    
        # 休符の処理
        if token.startswith('r'):
            self.debug_print("Processing as rest", level=3)
            duration = token[1:] if len(token) > 1 else default_duration
            self._validate_duration(duration)
            return Note(
                string=0,
                fret="0",
                duration=duration,
                chord=chord,
                is_rest=True
            )
    
        # 弦移動の処理
        if token.startswith('u') or token.startswith('d'):
            direction = token[0]
            try:
                fret = token[1:].split(':')[0]  # 移動後のフレット番号
    
                # 弦番号の計算
                if direction == 'u':
                    string = self.last_string - 1  # 1弦上に移動
                else:  # direction == 'd'
                    string = self.last_string + 1  # 1弦下に移動
    
                # 弦番号の範囲チェック
                if string < 1:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # チューニングに基づいて弦の数を決定
                if self.score.tuning == "guitar":
                    max_strings = 6
                elif self.score.tuning == "bass":
                    max_strings = 4
                elif self.score.tuning == "ukulele":
                    max_strings = 4
                elif self.score.tuning == "guitar7":
                    max_strings = 7
                elif self.score.tuning == "bass5":
                    max_strings = 5
                else:
                    max_strings = 6  # デフォルト
    
                # 弦番号の範囲チェック（下限）
                if string > max_strings:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # 弦番号を更新
                self.last_string = string
    
                # 音価の取得
                if ':' in token:
                    duration = token.split(':')[1]
                else:
                    duration = default_duration
    
                # 新しい音符を作成して返す
                return Note(
                    string=string,
                    fret=fret,
                    duration=duration,
                    chord=chord,
                    is_up_move=(direction == 'u'),
                    is_down_move=(direction == 'd')
                )
            except ValueError:
                raise ParseError(f"Invalid string movement: {token}", self.current_line)
    
        # 弦-フレット形式の解析
        if '-' in token:
            string_fret = token.split('-')
            string = int(string_fret[0])
            fret = string_fret[1].upper()  # フレット番号を大文字に統一
    
            # 0-0は休符として扱う
            is_rest = (string == 0 and fret == "0")
    
            # ミュート音の処理
            is_muted = (fret == "X")
    
            # フレット番号の検証（ミュート音以外）
            if not is_muted and not is_rest:
>               self._validate_fret(fret)
E               AttributeError: 'Parser' object has no attribute '_validate_fret'

src/tabscript/parser.py:716: AttributeError
_____________________________ test_chord_notation ______________________________

    def test_chord_notation():
        """和音記法のテスト"""
        parser = Parser()
        parser.score = Score(title="", tuning="guitar", beat="4/4")
    
        # 基本的な和音
>       bar = parser._parse_bar_line("(1-0 2-0 3-0):4")

tests/parser/test_03_bar_content.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/tabscript/parser.py:502: in _parse_bar_line
    note = self._parse_note(note_str, duration, chord)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tabscript.parser.Parser object at 0x109b394d0>, token = '1-0'
default_duration = '4', chord = None

    def _parse_note(self, token: str, default_duration: str = "4", chord: Optional[str] = None) -> Note:
        """音符トークンをパース"""
        self.debug_print(f"Processing token: {token}", level=3)
    
        # コード形式の音符（括弧で囲まれた複数の音符）
        if token.startswith('(') and ')' in token:
            self.debug_print("Processing as chord notation", level=3)
    
            # 括弧内の音符と音価を分離
            chord_part, *rest = token.split(')')
            chord_notes_str = chord_part[1:]  # 先頭の'('を除去
    
            # 音価の取得
            duration = default_duration
            if rest and ':' in rest[0]:
                duration = rest[0].split(':')[1]
                self.debug_print(f"Chord duration: {duration}", level=3)
    
            # 括弧内の音符をパース
            chord_notes = []
            for note_str in chord_notes_str.split():
                # コード内の音符は音価を持たない（コード全体の音価を使用）
                if ':' in note_str:
                    note_str = note_str.split(':')[0]
    
                # 個々の音符をパース
                note = self._parse_note(note_str, duration, chord)
                note.duration = duration  # コード全体の音価を設定
                note.is_chord = True  # コードの一部であることを明示
                chord_notes.append(note)
    
            # コードの先頭音符を返す（他の音符はchord_notesに格納）
            if chord_notes:
                main_note = chord_notes[0]
                main_note.is_chord_start = True  # コードの先頭音符であることを明示
                main_note.chord_notes = chord_notes[1:]  # 先頭以外の音符
                self.debug_print(f"Created chord with {len(chord_notes)} notes, duration={main_note.duration}", level=3)
                return main_note
            else:
                raise ParseError(f"Empty chord notation: {token}", self.current_line)
    
        # 休符の処理
        if token.startswith('r'):
            self.debug_print("Processing as rest", level=3)
            duration = token[1:] if len(token) > 1 else default_duration
            self._validate_duration(duration)
            return Note(
                string=0,
                fret="0",
                duration=duration,
                chord=chord,
                is_rest=True
            )
    
        # 弦移動の処理
        if token.startswith('u') or token.startswith('d'):
            direction = token[0]
            try:
                fret = token[1:].split(':')[0]  # 移動後のフレット番号
    
                # 弦番号の計算
                if direction == 'u':
                    string = self.last_string - 1  # 1弦上に移動
                else:  # direction == 'd'
                    string = self.last_string + 1  # 1弦下に移動
    
                # 弦番号の範囲チェック
                if string < 1:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # チューニングに基づいて弦の数を決定
                if self.score.tuning == "guitar":
                    max_strings = 6
                elif self.score.tuning == "bass":
                    max_strings = 4
                elif self.score.tuning == "ukulele":
                    max_strings = 4
                elif self.score.tuning == "guitar7":
                    max_strings = 7
                elif self.score.tuning == "bass5":
                    max_strings = 5
                else:
                    max_strings = 6  # デフォルト
    
                # 弦番号の範囲チェック（下限）
                if string > max_strings:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # 弦番号を更新
                self.last_string = string
    
                # 音価の取得
                if ':' in token:
                    duration = token.split(':')[1]
                else:
                    duration = default_duration
    
                # 新しい音符を作成して返す
                return Note(
                    string=string,
                    fret=fret,
                    duration=duration,
                    chord=chord,
                    is_up_move=(direction == 'u'),
                    is_down_move=(direction == 'd')
                )
            except ValueError:
                raise ParseError(f"Invalid string movement: {token}", self.current_line)
    
        # 弦-フレット形式の解析
        if '-' in token:
            string_fret = token.split('-')
            string = int(string_fret[0])
            fret = string_fret[1].upper()  # フレット番号を大文字に統一
    
            # 0-0は休符として扱う
            is_rest = (string == 0 and fret == "0")
    
            # ミュート音の処理
            is_muted = (fret == "X")
    
            # フレット番号の検証（ミュート音以外）
            if not is_muted and not is_rest:
>               self._validate_fret(fret)
E               AttributeError: 'Parser' object has no attribute '_validate_fret'

src/tabscript/parser.py:716: AttributeError
_______________________________ test_inheritance _______________________________

    def test_inheritance():
        """弦番号と音価の継承をテスト"""
        parser = Parser()
        parser.debug_mode = True
        parser.score = Score(title="", tuning="guitar", beat="4/4")
    
        # 弦番号の継承
>       bar = parser._parse_bar_line("6-1 2 3 4")

tests/parser/test_03_bar_content.py:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/tabscript/parser.py:575: in _parse_bar_line
    note = self._parse_note(token, self.last_duration, chord)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tabscript.parser.Parser object at 0x1097f3350>, token = '6-1'
default_duration = '4', chord = None

    def _parse_note(self, token: str, default_duration: str = "4", chord: Optional[str] = None) -> Note:
        """音符トークンをパース"""
        self.debug_print(f"Processing token: {token}", level=3)
    
        # コード形式の音符（括弧で囲まれた複数の音符）
        if token.startswith('(') and ')' in token:
            self.debug_print("Processing as chord notation", level=3)
    
            # 括弧内の音符と音価を分離
            chord_part, *rest = token.split(')')
            chord_notes_str = chord_part[1:]  # 先頭の'('を除去
    
            # 音価の取得
            duration = default_duration
            if rest and ':' in rest[0]:
                duration = rest[0].split(':')[1]
                self.debug_print(f"Chord duration: {duration}", level=3)
    
            # 括弧内の音符をパース
            chord_notes = []
            for note_str in chord_notes_str.split():
                # コード内の音符は音価を持たない（コード全体の音価を使用）
                if ':' in note_str:
                    note_str = note_str.split(':')[0]
    
                # 個々の音符をパース
                note = self._parse_note(note_str, duration, chord)
                note.duration = duration  # コード全体の音価を設定
                note.is_chord = True  # コードの一部であることを明示
                chord_notes.append(note)
    
            # コードの先頭音符を返す（他の音符はchord_notesに格納）
            if chord_notes:
                main_note = chord_notes[0]
                main_note.is_chord_start = True  # コードの先頭音符であることを明示
                main_note.chord_notes = chord_notes[1:]  # 先頭以外の音符
                self.debug_print(f"Created chord with {len(chord_notes)} notes, duration={main_note.duration}", level=3)
                return main_note
            else:
                raise ParseError(f"Empty chord notation: {token}", self.current_line)
    
        # 休符の処理
        if token.startswith('r'):
            self.debug_print("Processing as rest", level=3)
            duration = token[1:] if len(token) > 1 else default_duration
            self._validate_duration(duration)
            return Note(
                string=0,
                fret="0",
                duration=duration,
                chord=chord,
                is_rest=True
            )
    
        # 弦移動の処理
        if token.startswith('u') or token.startswith('d'):
            direction = token[0]
            try:
                fret = token[1:].split(':')[0]  # 移動後のフレット番号
    
                # 弦番号の計算
                if direction == 'u':
                    string = self.last_string - 1  # 1弦上に移動
                else:  # direction == 'd'
                    string = self.last_string + 1  # 1弦下に移動
    
                # 弦番号の範囲チェック
                if string < 1:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # チューニングに基づいて弦の数を決定
                if self.score.tuning == "guitar":
                    max_strings = 6
                elif self.score.tuning == "bass":
                    max_strings = 4
                elif self.score.tuning == "ukulele":
                    max_strings = 4
                elif self.score.tuning == "guitar7":
                    max_strings = 7
                elif self.score.tuning == "bass5":
                    max_strings = 5
                else:
                    max_strings = 6  # デフォルト
    
                # 弦番号の範囲チェック（下限）
                if string > max_strings:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # 弦番号を更新
                self.last_string = string
    
                # 音価の取得
                if ':' in token:
                    duration = token.split(':')[1]
                else:
                    duration = default_duration
    
                # 新しい音符を作成して返す
                return Note(
                    string=string,
                    fret=fret,
                    duration=duration,
                    chord=chord,
                    is_up_move=(direction == 'u'),
                    is_down_move=(direction == 'd')
                )
            except ValueError:
                raise ParseError(f"Invalid string movement: {token}", self.current_line)
    
        # 弦-フレット形式の解析
        if '-' in token:
            string_fret = token.split('-')
            string = int(string_fret[0])
            fret = string_fret[1].upper()  # フレット番号を大文字に統一
    
            # 0-0は休符として扱う
            is_rest = (string == 0 and fret == "0")
    
            # ミュート音の処理
            is_muted = (fret == "X")
    
            # フレット番号の検証（ミュート音以外）
            if not is_muted and not is_rest:
>               self._validate_fret(fret)
E               AttributeError: 'Parser' object has no attribute '_validate_fret'

src/tabscript/parser.py:716: AttributeError
______________________________ test_move_notation ______________________________

    def test_move_notation():
        """移動記号のパースをテスト"""
        parser = Parser()
        parser.debug_mode = True
        parser.score = Score(title="", tuning="guitar", beat="4/4")
    
        # 上移動
>       bar = parser._parse_bar_line("5-3:8 5 u2 3")

tests/parser/test_03_bar_content.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/tabscript/parser.py:575: in _parse_bar_line
    note = self._parse_note(token, self.last_duration, chord)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tabscript.parser.Parser object at 0x109834c50>, token = '5-3:8'
default_duration = '4', chord = None

    def _parse_note(self, token: str, default_duration: str = "4", chord: Optional[str] = None) -> Note:
        """音符トークンをパース"""
        self.debug_print(f"Processing token: {token}", level=3)
    
        # コード形式の音符（括弧で囲まれた複数の音符）
        if token.startswith('(') and ')' in token:
            self.debug_print("Processing as chord notation", level=3)
    
            # 括弧内の音符と音価を分離
            chord_part, *rest = token.split(')')
            chord_notes_str = chord_part[1:]  # 先頭の'('を除去
    
            # 音価の取得
            duration = default_duration
            if rest and ':' in rest[0]:
                duration = rest[0].split(':')[1]
                self.debug_print(f"Chord duration: {duration}", level=3)
    
            # 括弧内の音符をパース
            chord_notes = []
            for note_str in chord_notes_str.split():
                # コード内の音符は音価を持たない（コード全体の音価を使用）
                if ':' in note_str:
                    note_str = note_str.split(':')[0]
    
                # 個々の音符をパース
                note = self._parse_note(note_str, duration, chord)
                note.duration = duration  # コード全体の音価を設定
                note.is_chord = True  # コードの一部であることを明示
                chord_notes.append(note)
    
            # コードの先頭音符を返す（他の音符はchord_notesに格納）
            if chord_notes:
                main_note = chord_notes[0]
                main_note.is_chord_start = True  # コードの先頭音符であることを明示
                main_note.chord_notes = chord_notes[1:]  # 先頭以外の音符
                self.debug_print(f"Created chord with {len(chord_notes)} notes, duration={main_note.duration}", level=3)
                return main_note
            else:
                raise ParseError(f"Empty chord notation: {token}", self.current_line)
    
        # 休符の処理
        if token.startswith('r'):
            self.debug_print("Processing as rest", level=3)
            duration = token[1:] if len(token) > 1 else default_duration
            self._validate_duration(duration)
            return Note(
                string=0,
                fret="0",
                duration=duration,
                chord=chord,
                is_rest=True
            )
    
        # 弦移動の処理
        if token.startswith('u') or token.startswith('d'):
            direction = token[0]
            try:
                fret = token[1:].split(':')[0]  # 移動後のフレット番号
    
                # 弦番号の計算
                if direction == 'u':
                    string = self.last_string - 1  # 1弦上に移動
                else:  # direction == 'd'
                    string = self.last_string + 1  # 1弦下に移動
    
                # 弦番号の範囲チェック
                if string < 1:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # チューニングに基づいて弦の数を決定
                if self.score.tuning == "guitar":
                    max_strings = 6
                elif self.score.tuning == "bass":
                    max_strings = 4
                elif self.score.tuning == "ukulele":
                    max_strings = 4
                elif self.score.tuning == "guitar7":
                    max_strings = 7
                elif self.score.tuning == "bass5":
                    max_strings = 5
                else:
                    max_strings = 6  # デフォルト
    
                # 弦番号の範囲チェック（下限）
                if string > max_strings:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # 弦番号を更新
                self.last_string = string
    
                # 音価の取得
                if ':' in token:
                    duration = token.split(':')[1]
                else:
                    duration = default_duration
    
                # 新しい音符を作成して返す
                return Note(
                    string=string,
                    fret=fret,
                    duration=duration,
                    chord=chord,
                    is_up_move=(direction == 'u'),
                    is_down_move=(direction == 'd')
                )
            except ValueError:
                raise ParseError(f"Invalid string movement: {token}", self.current_line)
    
        # 弦-フレット形式の解析
        if '-' in token:
            string_fret = token.split('-')
            string = int(string_fret[0])
            fret = string_fret[1].upper()  # フレット番号を大文字に統一
    
            # 0-0は休符として扱う
            is_rest = (string == 0 and fret == "0")
    
            # ミュート音の処理
            is_muted = (fret == "X")
    
            # フレット番号の検証（ミュート音以外）
            if not is_muted and not is_rest:
>               self._validate_fret(fret)
E               AttributeError: 'Parser' object has no attribute '_validate_fret'

src/tabscript/parser.py:716: AttributeError
____________________________ test_tie_slur_notation ____________________________

    def test_tie_slur_notation():
        """タイ・スラー記法のテスト"""
        parser = Parser()
        parser.debug_mode = True
        parser.score = Score(title="", tuning="guitar", beat="4/4")
    
        # 音符にタイ・スラー
>       bar = parser._parse_bar_line("4-3& 5")

tests/parser/test_03_bar_content.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/tabscript/parser.py:575: in _parse_bar_line
    note = self._parse_note(token, self.last_duration, chord)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tabscript.parser.Parser object at 0x1098e2610>, token = '4-3&'
default_duration = '4', chord = None

    def _parse_note(self, token: str, default_duration: str = "4", chord: Optional[str] = None) -> Note:
        """音符トークンをパース"""
        self.debug_print(f"Processing token: {token}", level=3)
    
        # コード形式の音符（括弧で囲まれた複数の音符）
        if token.startswith('(') and ')' in token:
            self.debug_print("Processing as chord notation", level=3)
    
            # 括弧内の音符と音価を分離
            chord_part, *rest = token.split(')')
            chord_notes_str = chord_part[1:]  # 先頭の'('を除去
    
            # 音価の取得
            duration = default_duration
            if rest and ':' in rest[0]:
                duration = rest[0].split(':')[1]
                self.debug_print(f"Chord duration: {duration}", level=3)
    
            # 括弧内の音符をパース
            chord_notes = []
            for note_str in chord_notes_str.split():
                # コード内の音符は音価を持たない（コード全体の音価を使用）
                if ':' in note_str:
                    note_str = note_str.split(':')[0]
    
                # 個々の音符をパース
                note = self._parse_note(note_str, duration, chord)
                note.duration = duration  # コード全体の音価を設定
                note.is_chord = True  # コードの一部であることを明示
                chord_notes.append(note)
    
            # コードの先頭音符を返す（他の音符はchord_notesに格納）
            if chord_notes:
                main_note = chord_notes[0]
                main_note.is_chord_start = True  # コードの先頭音符であることを明示
                main_note.chord_notes = chord_notes[1:]  # 先頭以外の音符
                self.debug_print(f"Created chord with {len(chord_notes)} notes, duration={main_note.duration}", level=3)
                return main_note
            else:
                raise ParseError(f"Empty chord notation: {token}", self.current_line)
    
        # 休符の処理
        if token.startswith('r'):
            self.debug_print("Processing as rest", level=3)
            duration = token[1:] if len(token) > 1 else default_duration
            self._validate_duration(duration)
            return Note(
                string=0,
                fret="0",
                duration=duration,
                chord=chord,
                is_rest=True
            )
    
        # 弦移動の処理
        if token.startswith('u') or token.startswith('d'):
            direction = token[0]
            try:
                fret = token[1:].split(':')[0]  # 移動後のフレット番号
    
                # 弦番号の計算
                if direction == 'u':
                    string = self.last_string - 1  # 1弦上に移動
                else:  # direction == 'd'
                    string = self.last_string + 1  # 1弦下に移動
    
                # 弦番号の範囲チェック
                if string < 1:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # チューニングに基づいて弦の数を決定
                if self.score.tuning == "guitar":
                    max_strings = 6
                elif self.score.tuning == "bass":
                    max_strings = 4
                elif self.score.tuning == "ukulele":
                    max_strings = 4
                elif self.score.tuning == "guitar7":
                    max_strings = 7
                elif self.score.tuning == "bass5":
                    max_strings = 5
                else:
                    max_strings = 6  # デフォルト
    
                # 弦番号の範囲チェック（下限）
                if string > max_strings:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # 弦番号を更新
                self.last_string = string
    
                # 音価の取得
                if ':' in token:
                    duration = token.split(':')[1]
                else:
                    duration = default_duration
    
                # 新しい音符を作成して返す
                return Note(
                    string=string,
                    fret=fret,
                    duration=duration,
                    chord=chord,
                    is_up_move=(direction == 'u'),
                    is_down_move=(direction == 'd')
                )
            except ValueError:
                raise ParseError(f"Invalid string movement: {token}", self.current_line)
    
        # 弦-フレット形式の解析
        if '-' in token:
            string_fret = token.split('-')
            string = int(string_fret[0])
            fret = string_fret[1].upper()  # フレット番号を大文字に統一
    
            # 0-0は休符として扱う
            is_rest = (string == 0 and fret == "0")
    
            # ミュート音の処理
            is_muted = (fret == "X")
    
            # フレット番号の検証（ミュート音以外）
            if not is_muted and not is_rest:
>               self._validate_fret(fret)
E               AttributeError: 'Parser' object has no attribute '_validate_fret'

src/tabscript/parser.py:716: AttributeError
________________________ test_string_movement_notation _________________________

    def test_string_movement_notation():
        """上下移動記号のテスト"""
        parser = Parser(debug_mode=True)
        parser.score = Score(title="", tuning="guitar", beat="4/4")
        parser.last_string = 3  # 3弦から開始
    
        # 上移動（u）のテスト
        bar = parser._parse_bar_line("u2:4 u3:8")
>       assert len(bar.notes) == 2
E       AttributeError: 'Note' object has no attribute 'notes'

tests/parser/test_03_bar_content.py:304: AttributeError
__________________ test_string_movement_duration_calculation ___________________

    def test_string_movement_duration_calculation():
        """上下移動記号を含む小節の音価計算のテスト"""
        parser = Parser()
        parser.score = Score(title="", tuning="guitar", beat="4/4")
        parser.last_string = 5  # 5弦から開始
    
        # 上移動記号を含む小節
>       bar = parser._parse_bar_line("5-5:8 7 u4 5 7 u4 6 7")

tests/parser/test_03_bar_content.py:367: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/tabscript/parser.py:575: in _parse_bar_line
    note = self._parse_note(token, self.last_duration, chord)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tabscript.parser.Parser object at 0x1098682d0>, token = '5-5:8'
default_duration = '4', chord = None

    def _parse_note(self, token: str, default_duration: str = "4", chord: Optional[str] = None) -> Note:
        """音符トークンをパース"""
        self.debug_print(f"Processing token: {token}", level=3)
    
        # コード形式の音符（括弧で囲まれた複数の音符）
        if token.startswith('(') and ')' in token:
            self.debug_print("Processing as chord notation", level=3)
    
            # 括弧内の音符と音価を分離
            chord_part, *rest = token.split(')')
            chord_notes_str = chord_part[1:]  # 先頭の'('を除去
    
            # 音価の取得
            duration = default_duration
            if rest and ':' in rest[0]:
                duration = rest[0].split(':')[1]
                self.debug_print(f"Chord duration: {duration}", level=3)
    
            # 括弧内の音符をパース
            chord_notes = []
            for note_str in chord_notes_str.split():
                # コード内の音符は音価を持たない（コード全体の音価を使用）
                if ':' in note_str:
                    note_str = note_str.split(':')[0]
    
                # 個々の音符をパース
                note = self._parse_note(note_str, duration, chord)
                note.duration = duration  # コード全体の音価を設定
                note.is_chord = True  # コードの一部であることを明示
                chord_notes.append(note)
    
            # コードの先頭音符を返す（他の音符はchord_notesに格納）
            if chord_notes:
                main_note = chord_notes[0]
                main_note.is_chord_start = True  # コードの先頭音符であることを明示
                main_note.chord_notes = chord_notes[1:]  # 先頭以外の音符
                self.debug_print(f"Created chord with {len(chord_notes)} notes, duration={main_note.duration}", level=3)
                return main_note
            else:
                raise ParseError(f"Empty chord notation: {token}", self.current_line)
    
        # 休符の処理
        if token.startswith('r'):
            self.debug_print("Processing as rest", level=3)
            duration = token[1:] if len(token) > 1 else default_duration
            self._validate_duration(duration)
            return Note(
                string=0,
                fret="0",
                duration=duration,
                chord=chord,
                is_rest=True
            )
    
        # 弦移動の処理
        if token.startswith('u') or token.startswith('d'):
            direction = token[0]
            try:
                fret = token[1:].split(':')[0]  # 移動後のフレット番号
    
                # 弦番号の計算
                if direction == 'u':
                    string = self.last_string - 1  # 1弦上に移動
                else:  # direction == 'd'
                    string = self.last_string + 1  # 1弦下に移動
    
                # 弦番号の範囲チェック
                if string < 1:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # チューニングに基づいて弦の数を決定
                if self.score.tuning == "guitar":
                    max_strings = 6
                elif self.score.tuning == "bass":
                    max_strings = 4
                elif self.score.tuning == "ukulele":
                    max_strings = 4
                elif self.score.tuning == "guitar7":
                    max_strings = 7
                elif self.score.tuning == "bass5":
                    max_strings = 5
                else:
                    max_strings = 6  # デフォルト
    
                # 弦番号の範囲チェック（下限）
                if string > max_strings:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # 弦番号を更新
                self.last_string = string
    
                # 音価の取得
                if ':' in token:
                    duration = token.split(':')[1]
                else:
                    duration = default_duration
    
                # 新しい音符を作成して返す
                return Note(
                    string=string,
                    fret=fret,
                    duration=duration,
                    chord=chord,
                    is_up_move=(direction == 'u'),
                    is_down_move=(direction == 'd')
                )
            except ValueError:
                raise ParseError(f"Invalid string movement: {token}", self.current_line)
    
        # 弦-フレット形式の解析
        if '-' in token:
            string_fret = token.split('-')
            string = int(string_fret[0])
            fret = string_fret[1].upper()  # フレット番号を大文字に統一
    
            # 0-0は休符として扱う
            is_rest = (string == 0 and fret == "0")
    
            # ミュート音の処理
            is_muted = (fret == "X")
    
            # フレット番号の検証（ミュート音以外）
            if not is_muted and not is_rest:
>               self._validate_fret(fret)
E               AttributeError: 'Parser' object has no attribute '_validate_fret'

src/tabscript/parser.py:716: AttributeError
_______________________ test_chord_duration_calculation ________________________

    def test_chord_duration_calculation():
        """和音の音価計算のテスト"""
        parser = Parser()
        parser.score = Score(title="", tuning="guitar", beat="4/4")
    
        # 和音を含む小節の音価計算
>       bar = parser._parse_bar_line("@C (1-3 2-5 3-5 4-5 5-3 6-3):4 (1-x 2-x 3-x 4-x 5-x 6-x):4 (1-x 2-x 3-x 4-x 5-x 6-x):4 (1-x 2-x 3-x 4-x 5-x 6-x):4")

tests/parser/test_03_bar_content.py:384: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/tabscript/parser.py:502: in _parse_bar_line
    note = self._parse_note(note_str, duration, chord)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tabscript.parser.Parser object at 0x109a2c8d0>, token = '1-3'
default_duration = '4', chord = 'C'

    def _parse_note(self, token: str, default_duration: str = "4", chord: Optional[str] = None) -> Note:
        """音符トークンをパース"""
        self.debug_print(f"Processing token: {token}", level=3)
    
        # コード形式の音符（括弧で囲まれた複数の音符）
        if token.startswith('(') and ')' in token:
            self.debug_print("Processing as chord notation", level=3)
    
            # 括弧内の音符と音価を分離
            chord_part, *rest = token.split(')')
            chord_notes_str = chord_part[1:]  # 先頭の'('を除去
    
            # 音価の取得
            duration = default_duration
            if rest and ':' in rest[0]:
                duration = rest[0].split(':')[1]
                self.debug_print(f"Chord duration: {duration}", level=3)
    
            # 括弧内の音符をパース
            chord_notes = []
            for note_str in chord_notes_str.split():
                # コード内の音符は音価を持たない（コード全体の音価を使用）
                if ':' in note_str:
                    note_str = note_str.split(':')[0]
    
                # 個々の音符をパース
                note = self._parse_note(note_str, duration, chord)
                note.duration = duration  # コード全体の音価を設定
                note.is_chord = True  # コードの一部であることを明示
                chord_notes.append(note)
    
            # コードの先頭音符を返す（他の音符はchord_notesに格納）
            if chord_notes:
                main_note = chord_notes[0]
                main_note.is_chord_start = True  # コードの先頭音符であることを明示
                main_note.chord_notes = chord_notes[1:]  # 先頭以外の音符
                self.debug_print(f"Created chord with {len(chord_notes)} notes, duration={main_note.duration}", level=3)
                return main_note
            else:
                raise ParseError(f"Empty chord notation: {token}", self.current_line)
    
        # 休符の処理
        if token.startswith('r'):
            self.debug_print("Processing as rest", level=3)
            duration = token[1:] if len(token) > 1 else default_duration
            self._validate_duration(duration)
            return Note(
                string=0,
                fret="0",
                duration=duration,
                chord=chord,
                is_rest=True
            )
    
        # 弦移動の処理
        if token.startswith('u') or token.startswith('d'):
            direction = token[0]
            try:
                fret = token[1:].split(':')[0]  # 移動後のフレット番号
    
                # 弦番号の計算
                if direction == 'u':
                    string = self.last_string - 1  # 1弦上に移動
                else:  # direction == 'd'
                    string = self.last_string + 1  # 1弦下に移動
    
                # 弦番号の範囲チェック
                if string < 1:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # チューニングに基づいて弦の数を決定
                if self.score.tuning == "guitar":
                    max_strings = 6
                elif self.score.tuning == "bass":
                    max_strings = 4
                elif self.score.tuning == "ukulele":
                    max_strings = 4
                elif self.score.tuning == "guitar7":
                    max_strings = 7
                elif self.score.tuning == "bass5":
                    max_strings = 5
                else:
                    max_strings = 6  # デフォルト
    
                # 弦番号の範囲チェック（下限）
                if string > max_strings:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # 弦番号を更新
                self.last_string = string
    
                # 音価の取得
                if ':' in token:
                    duration = token.split(':')[1]
                else:
                    duration = default_duration
    
                # 新しい音符を作成して返す
                return Note(
                    string=string,
                    fret=fret,
                    duration=duration,
                    chord=chord,
                    is_up_move=(direction == 'u'),
                    is_down_move=(direction == 'd')
                )
            except ValueError:
                raise ParseError(f"Invalid string movement: {token}", self.current_line)
    
        # 弦-フレット形式の解析
        if '-' in token:
            string_fret = token.split('-')
            string = int(string_fret[0])
            fret = string_fret[1].upper()  # フレット番号を大文字に統一
    
            # 0-0は休符として扱う
            is_rest = (string == 0 and fret == "0")
    
            # ミュート音の処理
            is_muted = (fret == "X")
    
            # フレット番号の検証（ミュート音以外）
            if not is_muted and not is_rest:
>               self._validate_fret(fret)
E               AttributeError: 'Parser' object has no attribute '_validate_fret'

src/tabscript/parser.py:716: AttributeError
________________________ test_continued_string_movement ________________________

    def test_continued_string_movement():
        """弦移動が複数行にまたがる場合のテスト"""
        parser = Parser()
        parser.score = Score(title="", tuning="guitar", beat="4/4")
    
        # 1行目: 5弦から開始して上移動を含む
>       bar1 = parser._parse_bar_line("5-3:8 5 u2 3 5 u2 4 5")

tests/parser/test_03_bar_content.py:401: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/tabscript/parser.py:575: in _parse_bar_line
    note = self._parse_note(token, self.last_duration, chord)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tabscript.parser.Parser object at 0x109a32910>, token = '5-3:8'
default_duration = '4', chord = None

    def _parse_note(self, token: str, default_duration: str = "4", chord: Optional[str] = None) -> Note:
        """音符トークンをパース"""
        self.debug_print(f"Processing token: {token}", level=3)
    
        # コード形式の音符（括弧で囲まれた複数の音符）
        if token.startswith('(') and ')' in token:
            self.debug_print("Processing as chord notation", level=3)
    
            # 括弧内の音符と音価を分離
            chord_part, *rest = token.split(')')
            chord_notes_str = chord_part[1:]  # 先頭の'('を除去
    
            # 音価の取得
            duration = default_duration
            if rest and ':' in rest[0]:
                duration = rest[0].split(':')[1]
                self.debug_print(f"Chord duration: {duration}", level=3)
    
            # 括弧内の音符をパース
            chord_notes = []
            for note_str in chord_notes_str.split():
                # コード内の音符は音価を持たない（コード全体の音価を使用）
                if ':' in note_str:
                    note_str = note_str.split(':')[0]
    
                # 個々の音符をパース
                note = self._parse_note(note_str, duration, chord)
                note.duration = duration  # コード全体の音価を設定
                note.is_chord = True  # コードの一部であることを明示
                chord_notes.append(note)
    
            # コードの先頭音符を返す（他の音符はchord_notesに格納）
            if chord_notes:
                main_note = chord_notes[0]
                main_note.is_chord_start = True  # コードの先頭音符であることを明示
                main_note.chord_notes = chord_notes[1:]  # 先頭以外の音符
                self.debug_print(f"Created chord with {len(chord_notes)} notes, duration={main_note.duration}", level=3)
                return main_note
            else:
                raise ParseError(f"Empty chord notation: {token}", self.current_line)
    
        # 休符の処理
        if token.startswith('r'):
            self.debug_print("Processing as rest", level=3)
            duration = token[1:] if len(token) > 1 else default_duration
            self._validate_duration(duration)
            return Note(
                string=0,
                fret="0",
                duration=duration,
                chord=chord,
                is_rest=True
            )
    
        # 弦移動の処理
        if token.startswith('u') or token.startswith('d'):
            direction = token[0]
            try:
                fret = token[1:].split(':')[0]  # 移動後のフレット番号
    
                # 弦番号の計算
                if direction == 'u':
                    string = self.last_string - 1  # 1弦上に移動
                else:  # direction == 'd'
                    string = self.last_string + 1  # 1弦下に移動
    
                # 弦番号の範囲チェック
                if string < 1:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # チューニングに基づいて弦の数を決定
                if self.score.tuning == "guitar":
                    max_strings = 6
                elif self.score.tuning == "bass":
                    max_strings = 4
                elif self.score.tuning == "ukulele":
                    max_strings = 4
                elif self.score.tuning == "guitar7":
                    max_strings = 7
                elif self.score.tuning == "bass5":
                    max_strings = 5
                else:
                    max_strings = 6  # デフォルト
    
                # 弦番号の範囲チェック（下限）
                if string > max_strings:
                    raise ParseError(f"Invalid string movement: {token} (results in string {string})", self.current_line)
    
                # 弦番号を更新
                self.last_string = string
    
                # 音価の取得
                if ':' in token:
                    duration = token.split(':')[1]
                else:
                    duration = default_duration
    
                # 新しい音符を作成して返す
                return Note(
                    string=string,
                    fret=fret,
                    duration=duration,
                    chord=chord,
                    is_up_move=(direction == 'u'),
                    is_down_move=(direction == 'd')
                )
            except ValueError:
                raise ParseError(f"Invalid string movement: {token}", self.current_line)
    
        # 弦-フレット形式の解析
        if '-' in token:
            string_fret = token.split('-')
            string = int(string_fret[0])
            fret = string_fret[1].upper()  # フレット番号を大文字に統一
    
            # 0-0は休符として扱う
            is_rest = (string == 0 and fret == "0")
    
            # ミュート音の処理
            is_muted = (fret == "X")
    
            # フレット番号の検証（ミュート音以外）
            if not is_muted and not is_rest:
>               self._validate_fret(fret)
E               AttributeError: 'Parser' object has no attribute '_validate_fret'

src/tabscript/parser.py:716: AttributeError
=========================== short test summary info ============================
FAILED tests/parser/test_03_bar_content.py::test_basic_note_parsing - Attribu...
FAILED tests/parser/test_03_bar_content.py::test_chord_parsing - AttributeErr...
FAILED tests/parser/test_03_bar_content.py::test_rest_parsing - AttributeErro...
FAILED tests/parser/test_03_bar_content.py::test_duration_inheritance - Attri...
FAILED tests/parser/test_03_bar_content.py::test_dotted_duration - AttributeE...
FAILED tests/parser/test_03_bar_content.py::test_invalid_note_format - Attrib...
FAILED tests/parser/test_03_bar_content.py::test_muted_note - AttributeError:...
FAILED tests/parser/test_03_bar_content.py::test_chord_notation - AttributeEr...
FAILED tests/parser/test_03_bar_content.py::test_inheritance - AttributeError...
FAILED tests/parser/test_03_bar_content.py::test_move_notation - AttributeErr...
FAILED tests/parser/test_03_bar_content.py::test_tie_slur_notation - Attribut...
FAILED tests/parser/test_03_bar_content.py::test_string_movement_notation - A...
FAILED tests/parser/test_03_bar_content.py::test_string_movement_duration_calculation
FAILED tests/parser/test_03_bar_content.py::test_chord_duration_calculation
FAILED tests/parser/test_03_bar_content.py::test_continued_string_movement - ...
========================= 15 failed, 3 passed in 0.86s =========================
